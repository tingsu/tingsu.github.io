Android Papers
<br>
------
<br>
PUMA: Programmable UI-Automation for Large Scale Dynamic Analysis of Mobile Apps <a href="http://www.cs.usc.edu/assets/007/89796.pdf">link</a> (Yao Yao)
<br>
<li>PUMA tool: <a href="https://github.com/USC-NSL/PUMA">github</a>, <a href="http://nsl.cs.usc.edu/Talks/?action=download&upname=hao_mobisys14_puma.pptx">ppt</a>, <a href="http://nsl.cs.usc.edu/Projects/PUMA">project</a></li>
Characterizing and Detecting Resource Leaks in Android Applications: <a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6693097">link</a>
<br>
Versatile yet Lightweight Record-and-Replay for Android, <a href="http://www.cs.ucr.edu/~neamtiu/pubs/oopsla15hu.pdf">link</a>
<br>
Systematic Testing for Resource Leaks in Android Applications. <a href="http://dacongy.github.io/papers/yan-issre13.pdf">link</a>
<br>
Effective Test Suites for Mixed Discrete-Continuous Stateflow Controllers, a blackbox testing idea, <a href="http://dl.acm.org/citation.cfm?id=2786818">link</a>
<br>
Mimic: Computing Models for Opaque Code (with replication package), using MCMC to behaviour learning, <a href="http://dl.acm.org/citation.cfm?id=2786875&CFID=715667377&CFTOKEN=44648324">link</a></li>
<br>
EvoDroid: Segmented Evolutionary Testing of Android Apps, <a href="http://dl.acm.org/citation.cfm?id=2635896">link</a>
<br>
Efficiently, Effectively Detecting Mobile App Bugs with AppDoctor, <a href="http://dl.acm.org/citation.cfm?id=2592813">link</a>
<br>
A Grey-box Approach for Automated GUI-Model Generation of Mobile Applications, <a href="http://dl.acm.org/citation.cfm?id=2450338">link</a>
<br>
<br>


Symbolic Execution Papers
<br>
------
<br>
ISSTA'15: Enhancing Reuse of Constraint Solutions to Improve Symbolic Execution <a href="http://dl.acm.org/citation.cfm?id=2771806">link</a>
<br>
ICST'15: Evaluating Symbolic Execution-based Test Tools <a href="http://mit.bme.hu/~micskeiz/papers/cseppento-micskei-icst-2015.pdf">link</a>
<br>
SEViz: A Tool for Visualizing Symbolic Execution <a href="http://mit.bme.hu/~micskeiz/papers/honfi-voros-micskei-icst2015-tool.pdf">link</a>
<br>
Bidirectional Symbolic Analysis for Effective Branch Testing <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=7296670&tag=1">link</a>
<br>
<br>

L* algorithm
<br>
------
<br>
Learning Regular Sets from Queries and Counterexamples (classic paper)
<br>
TLV: Abstraction through Testing, Learning, and Validation (FSE'15)
<br>
Guided GUI Testing of Android Apps with Minimal Restart and Approximate Learning (OOPSLA'13)
<br>
<br>


Ph.D Discussion Group
<br>
------
<br>
PLDI, FSE, ICSE, OSDI best papers: <a href="http://jeffhuang.com/best_paper_awards.html">link</a>
<br>
<br>


Interesting Tools
<br>
------
<br>
ANTLR: <a href="http://www.antlr.org/index.html">link</a>
<br>
an Android app crawler: <a href="https://github.com/Akdeniz/google-play-crawler">link</a>
<br>
MoDisco: a generic and extensible framework for model driven reverse engineering <a href="http://dl.acm.org/citation.cfm?id=1858996.1859032">link</a>
<br>

Terms
<br>
-----
<br>
are becoming increasingly prevalent
<br>
The above problem poses two separate challenges:
<br>
These approaches have limitations
<br>
Capture-replay approaches are tailored to a particular platform's event-dispatching mechanism
<br>
In contrast, model-based approaches are general-purpose, but they can require considerable manual effort
<br>
which has made significant strides in recent years
<br>
We seek to bring the benefits of concolic testing to event- driven programs
<br>
proposing a novel way to alleviate the path-explosion problem tailored to this class of programs
<br>
it is applicable to real programs that often contain parts that are beyond the scope of static analysis.
<br>
Moreover, the condition is inexpensive to check and occurs frequently in real apps, causing the savings to greatly offset the cost of checking it.
<br>
Source code snippet of music player app
<br>
In Android, the widgets on any screen of an app are organized in a tree called the view hierarchy
<br>
propose a radically different approach that is general and fully automatic.
<br>
This not only lets our approach avoid generating spurious events but also enables it to exhaustively generate orthogonal events.
<br>
threaten the ability to cover all widgets
<br>
a new concrete tap event guaranteed to take the path dictated by this constraint in the view hierarchy
<br>
highlights the complexity for concolic execution that a real platform like Android demands:
<br>
The first time the component is called, it generates a test randomly; there- after, it inputs tests from either the Concolic testing engine or the Subsumption analyzer.
<br>
Prior research has primarily focused on either unit or GUI testing of Android apps
<br>
EvoDroid overcomes a key shortcoming of using evolutionary techniques for system testing
<br>
identifies the segments of the code amenable to be searched independently
<br>
Our experi- ments have corroborated EvoDroidâ€™s ability to achieve significantly higher code coverage than existing Android testing tools.
<br>
Small organizations do not have the resources to sufficiently test their products, thereby defective apps are made available to the con- sumers of these markets.
<br>
The state-of-practice in automated system testing of Android apps is random testing.
<br>
a brute-force mechanism
<br>
reach comparable code coverage as that of Monkey.
<br>
The overall coverage is no better than the initial population (randomly generated tests)
<br>
To that end, it had to overcome the concep- tual challenges of using evolutionary techniques for system testing.
<br>
employs a step-wise evolu- tionary test generation algorithm
<br>
address scalability issues
<br>
The test cases are evaluated based on a fitness function that rewards code coverage and uniqueness of the covered path.
<br>
This has been and continues to be the focus of many research efforts.
<br>
Errors in the GUI can manifest themselves as failures of the overall software.
<br>
To counteract this exponential test suite growth, another approach, and the one used in this paper, is to automatically generate test cases based on usage information,
<br>
employ the profiles to populate a probabilis- tic model of the GUI application
<br>
the prior probability calculation are extended from single events to sequences of events.
<br>
Alternatively, test cases (i.e., event sequences) can be generated based on con- catenating pairs of events that have the highest probability of occurring.
<br>
the Android framework transfers the burden of resource management to the developers




